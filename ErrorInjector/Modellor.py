import torch
import os, json

import sys
from ErrorInjector.MaskInjector import MaskInjector
from ErrorInjector.ErrorInjector import ErrorInjector

from Kernel.Kernel_execution import complete
from utils.args import args

import numpy as np
from sfpy import *

from Schedulers import *

faulty_Cluster = int(args.faults.faulty_Cluster) 
faulty_SM = int(args.faults.faulty_SM)

class Modellor(ErrorInjector,MaskInjector):
    def __init__(self,Scheduler,imported = True, update = False):#imported falg is specifing if we are importing in a bigger env with respect to Schedulers
        self._update = update                                    #update flag is specifing if we are using the models or creating them from experiment data
        self._imported = imported
        self._Scheduler = Scheduler
        self.MatrixMethod = ErrorInjector.__dict__['Float16_MatrixMul']#GEMM_v2
        self.method = ErrorInjector.__dict__['Float16Conversion']
        self.MaskInjection = MaskInjector.__dict__['ApplyMask']
        self._SchedulerAllocationMethod = ErrorInjector.__dict__['AllocateScheduler']
        
        self.__scheduler = self._SchedulerAllocationMethod(self,self._Scheduler)
        if not(self._update):
            self._Models = self.ReadModels()
        else:
            self._Models = [] 


    def FaultModelMatrixMul(self,ModelID ,a, b): #GEMM_v3
        golden_torch = self.MatrixMethod(self,a,b)
        Faulty_np = golden_torch.numpy().copy()
        self.AllocateCTA(a.numpy(),b.numpy(),Faulty_np)

        for CTA in self._CTAs : 
            if CTA['Cluster'] == faulty_Cluster and CTA['SM'] == faulty_SM :
                try:
                    Masks = self._Models[ModelID]['Masks']
                except:
                    print('Wrong Model ID')
                    sys.exit()

                for coordinate in Masks[int(CTA['CTA']['id'] % len(Masks))] :  #Masks is a list of dictionary {str(x,y) : Mask}
                    _x , _y = eval(coordinate)
                    try :
                        Faulty_np[CTA['CTA']['x'] + _x][CTA['CTA']['y'] + _y ] = self.MaskInjection.ApplyMask( self, 
                                        Float16(Faulty_np[CTA['CTA']['x'] + _x][CTA['CTA']['y'] + _y ]), Masks[int(CTA['CTA']['id'] % len(Masks))][coordinate])

                    except: #This is an excpetion raised since curropting an entrance introduced by zero padding that is removed later
                        #print('Excpetion')
                        pass
        return torch.from_numpy(Faulty_np)

    def AssignFaultToModel(self,Masks,AvgAbsError,MaxAbsError,MinAbsError, FaultID):
        
        for Model in range(len(self._Models)):
            
            Tested = False
            zero = False
            if AvgAbsError == 0.0: #Avoid division by zero exceptions
                zero = True
                if AvgAbsError == self._Models[Model]['AvgAbsError'] :
                    Tested = True
                else : 
                    Tested = False

            if (Tested or (not(zero) and 0.1 < self._Models[Model]['AvgAbsError']/AvgAbsError < 10 and
                    0.1 < self._Models[Model]['MaxAbsError']/MaxAbsError < 10 and
                                0.1 < self._Models[Model]['MinAbsError']/MinAbsError < 10)): #if the fault introduce similar error --> controlling spatial propagation
                
                Associate = True
                for CTA in range(len(Masks)):
                    for model in range(len(self._Models[Model]['Masks'])):
                        for coordinate in self._Models[Model]['Masks'][model] : #Masks is a dictionary {(x', y') : Mask}-->Generated by Mask injector--> Tested by ErrorInjector -->Assigned to a model or generate a model
                    
                            try:
                                bitFlips = Masks[CTA][coordinate]
                            except KeyError: #faults have different spatial propagation
                                Associate = False 
                                break
                
                if Associate :
                    print('Associating this fault to an already existing model \n')
                    self._Models[Model]['FaultsAssociated'].append(FaultID)
                    return Associate
        return False #the fault has not been associated to any existing model must procede to create a new Model --> Call AddModel
    
    def AddModel(self,FaultID,Masks, AvgAbsError,MaxAbsError,MinAbsError):
        self._Models.append(
            {
                'ModelID' : len(self._Models),
                'FaultsAssociated' : [], 
                'Masks' : Masks, #this is a list of dict { str(x',y') : Mask}
                'AvgAbsError' : AvgAbsError,
                'MaxAbsError': MaxAbsError,
                'MinAbsError': MinAbsError
            }
        )
        self._Models[-1]['FaultsAssociated'].append(int(FaultID))
    
    def StoreModels(self):
        #Float16 are not Json serializable --> Transforming in hex
        for model in range (len(self._Models)):
            self._Models[model]['AvgAbsError'] = str(self._Models[model]['AvgAbsError'])
            self._Models[model]['MinAbsError'] = str(self._Models[model]['MinAbsError'])
            self._Models[model]['MaxAbsError'] = str(self._Models[model]['MaxAbsError'])

        if self._imported:
            path = os.path.join(os.getcwd(),'Schedulers', 'ErrorInjector','Models', str(self._Scheduler)+'.json')
        else:
            path = os.path.join(os.getcwd(),'ErrorInjector','Models', str(self._Scheduler)+'.json')

        with open(path, "w+") as JSONfile:
            json.dump(self._Models, JSONfile)
        JSONfile.close()

    def ReadModels(self):
        if self._imported :
            models_path = os.path.join(os.getcwd(),'Schedulers', 'ErrorInjector','Models', str(self._Scheduler)+'.json')
        else:
            models_path = os.path.join(os.getcwd(),'ErrorInjector','Models', str(self._Scheduler)+'.json')

        with open(models_path,  encoding='utf-8') as json_file:
            Models =  json.load(json_file)
            for model in range (len(Models)):
                Models[model]['AvgAbsError'] = float(Models[model]['AvgAbsError'])
                Models[model]['MinAbsError'] = float(Models[model]['MinAbsError'])
                Models[model]['MaxAbsError'] = float(Models[model]['MaxAbsError'])

                for CTA in range(len(Models[model]['Masks'])):
                    for coordinate in Models[model]['Masks'][CTA]:
                        Models[model]['Masks'][CTA][coordinate] = Float16(int(Models[model]['Masks'][CTA][coordinate],16)) #back from hex to FLoat16 
        return Models
    
    def AllocateCTA(self, a, b, c):
        a = complete(a)
        b = complete(b)
        c = complete(c)
        self._CTAs = self.__scheduler.scheduler_algorithm(a, b, c)

    def ModelIDs(self):
        return len(self._Models)
    
    def NumberFaultsAssociatedModelID(self,ModelID):
        return len(self._Models[ModelID]['FaultsAssociated'] ) #this function is used for fault coverage calculation

   